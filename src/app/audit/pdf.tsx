"use client";

import React from "react";
import { jsPDF } from "jspdf";
import autoTable from 'jspdf-autotable';

interface Recommendation {
  text: string;
  priority: "High" | "Medium" | "Low";
}

interface AuditReport {
  seo?: number;
  performance?: number;
  accessibility?: number;
  bestPractices?: number;
  analysis?: string;
  recommendations?: Recommendation[];
  loadingTime?: number;
  pageSize?: number;
  requests?: number;
}

interface PDFProps {
  report: AuditReport | null;
  url: string;
}

const PDFGenerator: React.FC<PDFProps> = ({ report, url }) => {
  const handleDownloadPDF = () => {
    if (!report) return;

    const pdf = new jsPDF("p", "mm", "a4");
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - margin * 2;
    let yPosition = margin;

    // Colors
    const primaryColor = [15, 118, 110];
    const secondaryColor = [20, 184, 166];
    const successColor = [34, 197, 94];
    const warningColor = [234, 179, 8];
    const dangerColor = [239, 68, 68];
    const lightColor = [248, 250, 252];
    const darkColor = [15, 23, 42];

    /** -------------------------------- COVER PAGE -------------------------------- **/
    // Background gradient
    pdf.setFillColor(15, 118, 110);
    pdf.rect(0, 0, pageWidth, pageHeight, "F");
    
    // Logo/Icon
    pdf.setFillColor(255, 255, 255, 0.1);
    pdf.circle(pageWidth / 2, 80, 40, "F");
    
    pdf.setFillColor(255, 255, 255);
    pdf.circle(pageWidth / 2, 80, 15, "F");
    
    // Title
    pdf.setTextColor(255, 255, 255);
    pdf.setFont("helvetica", "bold");
    pdf.setFontSize(32);
    pdf.text("SEO AUDIT REPORT", pageWidth / 2, 140, { align: "center" });

    pdf.setFontSize(18);
    pdf.setFont("helvetica", "normal");
    pdf.text("Comprehensive Website Analysis", pageWidth / 2, 155, {
      align: "center",
    });

    // Website URL
    pdf.setFontSize(14);
    pdf.text(`Website: ${url}`, pageWidth / 2, 180, { align: "center" });

    // Date
    pdf.setFontSize(12);
    pdf.text(
      `Generated on: ${new Date().toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      })}`,
      pageWidth / 2,
      195,
      { align: "center" }
    );

    // Footer
    pdf.setFontSize(10);
    pdf.text("Generated by RankSeo.in", pageWidth / 2, pageHeight - 30, {
      align: "center",
    });

    pdf.addPage();

    /** -------------------------------- EXECUTIVE SUMMARY -------------------------------- **/
    yPosition = margin;
    
    // Header
    pdf.setFillColor(...primaryColor);
    pdf.rect(margin, yPosition, contentWidth, 12, "F");
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.setFont("helvetica", "bold");
    pdf.text("EXECUTIVE SUMMARY", margin + 8, yPosition + 8);
    yPosition += 20;

    // Summary Content
    pdf.setTextColor(...darkColor);
    pdf.setFontSize(11);
    pdf.setFont("helvetica", "normal");
    
    const summaryText = `This comprehensive audit report for ${url} provides detailed insights into your website's performance across key metrics including SEO, Performance, Accessibility, and Best Practices. The analysis identifies strengths, weaknesses, and provides actionable recommendations for improvement.`;
    
    const summaryLines = pdf.splitTextToSize(summaryText, contentWidth);
    pdf.text(summaryLines, margin, yPosition);
    yPosition += summaryLines.length * 6 + 15;

    /** -------------------------------- SCORE OVERVIEW -------------------------------- **/
    // Header
    pdf.setFillColor(...primaryColor);
    pdf.rect(margin, yPosition, contentWidth, 12, "F");
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.text("SCORE OVERVIEW", margin + 8, yPosition + 8);
    yPosition += 20;

    // Score Cards
    const scores = [
      { label: "SEO", score: report.seo ?? 0, color: successColor },
      { label: "Performance", score: report.performance ?? 0, color: secondaryColor },
      { label: "Accessibility", score: report.accessibility ?? 0, color: warningColor },
      { label: "Best Practices", score: report.bestPractices ?? 0, color: primaryColor },
    ];

    const cardWidth = contentWidth / 2 - 5;
    let cardX = margin;

    scores.forEach((item, index) => {
      if (index % 2 === 0 && index !== 0) {
        cardX = margin;
        yPosition += 35;
      }

      // Card background
      pdf.setFillColor(...lightColor);
      pdf.roundedRect(cardX, yPosition, cardWidth, 30, 3, 3, "F");
      pdf.setDrawColor(226, 232, 240);
      pdf.roundedRect(cardX, yPosition, cardWidth, 30, 3, 3, "D");

      // Score circle
      pdf.setFillColor(...item.color);
      pdf.circle(cardX + 20, yPosition + 15, 10, "F");
      
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(12);
      pdf.setFont("helvetica", "bold");
      pdf.text(item.score.toString(), cardX + 20, yPosition + 18, { align: "center" });

      // Label
      pdf.setTextColor(...darkColor);
      pdf.setFontSize(10);
      pdf.setFont("helvetica", "bold");
      pdf.text(item.label, cardX + 40, yPosition + 12);

      // Status
      let status = "";
      let statusColor = darkColor;
      if (item.score >= 90) {
        status = "Excellent";
        statusColor = successColor;
      } else if (item.score >= 70) {
        status = "Good";
        statusColor = secondaryColor;
      } else if (item.score >= 50) {
        status = "Needs Improvement";
        statusColor = warningColor;
      } else {
        status = "Poor";
        statusColor = dangerColor;
      }

      pdf.setTextColor(...statusColor);
      pdf.setFontSize(9);
      pdf.setFont("helvetica", "normal");
      pdf.text(status, cardX + 40, yPosition + 20);

      cardX += cardWidth + 10;
    });

    yPosition += 40;

    /** -------------------------------- PERFORMANCE METRICS -------------------------------- **/
    if (report.loadingTime || report.pageSize || report.requests) {
      pdf.setFillColor(...primaryColor);
      pdf.rect(margin, yPosition, contentWidth, 12, "F");
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(16);
      pdf.text("PERFORMANCE METRICS", margin + 8, yPosition + 8);
      yPosition += 20;

      const metrics = [
        { label: "Loading Time", value: `${report.loadingTime || 0}s`, icon: "â±ï¸" },
        { label: "Page Size", value: `${report.pageSize || 0}MB`, icon: "ðŸ“Š" },
        { label: "Requests", value: report.requests?.toString() || "0", icon: "ðŸ”—" },
      ];

      const metricWidth = contentWidth / 3 - 7;

      metrics.forEach((metric, index) => {
        const xPos = margin + (index * (metricWidth + 10));

        pdf.setFillColor(...lightColor);
        pdf.roundedRect(xPos, yPosition, metricWidth, 25, 3, 3, "F");
        pdf.setDrawColor(226, 232, 240);
        pdf.roundedRect(xPos, yPosition, metricWidth, 25, 3, 3, "D");

        pdf.setTextColor(...darkColor);
        pdf.setFontSize(9);
        pdf.text(metric.icon, xPos + 8, yPosition + 10);
        
        pdf.setFontSize(8);
        pdf.text(metric.label, xPos + 20, yPosition + 10);
        
        pdf.setFontSize(10);
        pdf.setFont("helvetica", "bold");
        pdf.text(metric.value, xPos + (metricWidth / 2), yPosition + 20, { align: "center" });
      });

      yPosition += 40;
    }

    /** -------------------------------- SCORE CHART -------------------------------- **/
    pdf.setFillColor(...primaryColor);
    pdf.rect(margin, yPosition, contentWidth, 12, "F");
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.text("PERFORMANCE COMPARISON", margin + 8, yPosition + 8);
    yPosition += 20;

    // Create bar chart
    const chartWidth = contentWidth;
    const chartHeight = 80;
    const chartX = margin;
    const chartY = yPosition;
    const barWidth = (chartWidth - 40) / 4;
    const maxScore = 100;

    // Chart background
    pdf.setFillColor(...lightColor);
    pdf.rect(chartX, chartY, chartWidth, chartHeight, "F");
    pdf.setDrawColor(226, 232, 240);
    pdf.rect(chartX, chartY, chartWidth, chartHeight, "D");

    // Y-axis labels
    pdf.setTextColor(100, 100, 100);
    pdf.setFontSize(8);
    for (let i = 0; i <= 5; i++) {
      const score = i * 20;
      const y = chartY + chartHeight - (score / maxScore) * chartHeight;
      pdf.text(score.toString(), chartX - 5, y, { align: "right" });
      pdf.setDrawColor(240, 240, 240);
      pdf.line(chartX, y, chartX + chartWidth, y);
    }

    // Bars
    scores.forEach((item, index) => {
      const barX = chartX + 20 + (index * (barWidth + 10));
      const barHeight = (item.score / maxScore) * (chartHeight - 20);
      const barY = chartY + chartHeight - barHeight;

      pdf.setFillColor(...item.color);
      pdf.rect(barX, barY, barWidth, barHeight, "F");

      // Score label
      pdf.setTextColor(...darkColor);
      pdf.setFontSize(9);
      pdf.setFont("helvetica", "bold");
      pdf.text(item.score.toString(), barX + (barWidth / 2), barY - 5, { align: "center" });

      // Category label
      pdf.setFontSize(8);
      pdf.setFont("helvetica", "normal");
      pdf.text(item.label, barX + (barWidth / 2), chartY + chartHeight + 5, { align: "center" });
    });

    yPosition += chartHeight + 25;

    /** -------------------------------- DETAILED ANALYSIS -------------------------------- **/
    if (report.analysis) {
      if (yPosition > pageHeight - 50) {
        pdf.addPage();
        yPosition = margin;
      }

      pdf.setFillColor(...primaryColor);
      pdf.rect(margin, yPosition, contentWidth, 12, "F");
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(16);
      pdf.text("DETAILED ANALYSIS", margin + 8, yPosition + 8);
      yPosition += 20;

      // Clean and format analysis text
      const cleanAnalysis = cleanAnalysisText(report.analysis);
      const analysisLines = pdf.splitTextToSize(cleanAnalysis, contentWidth);
      
      analysisLines.forEach((line: string) => {
        if (yPosition > pageHeight - 15) {
          pdf.addPage();
          yPosition = margin;
        }
        
        pdf.setTextColor(...darkColor);
        pdf.setFontSize(10);
        pdf.setFont("helvetica", "normal");
        
        // Check if this is a section header
        if (line.match(/^[A-Z][A-Za-z\s]+:$/)) {
          pdf.setFont("helvetica", "bold");
          pdf.setTextColor(...primaryColor);
          pdf.text(line, margin, yPosition);
          yPosition += 6;
          pdf.setFont("helvetica", "normal");
          pdf.setTextColor(...darkColor);
        } else {
          pdf.text(`â€¢ ${line}`, margin, yPosition);
          yPosition += 5;
        }
      });

      yPosition += 10;
    }

    /** -------------------------------- RECOMMENDATIONS TABLE -------------------------------- **/
    if (report.recommendations && report.recommendations.length > 0) {
      if (yPosition > pageHeight - 50) {
        pdf.addPage();
        yPosition = margin;
      }

      pdf.setFillColor(...primaryColor);
      pdf.rect(margin, yPosition, contentWidth, 12, "F");
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(16);
      pdf.text("RECOMMENDATIONS", margin + 8, yPosition + 8);
      yPosition += 20;

      // Prepare table data
      const tableData = report.recommendations.map((rec, index) => [
        (index + 1).toString(),
        rec.text,
        rec.priority
      ]);

      autoTable(pdf, {
        startY: yPosition,
        head: [['#', 'Recommendation', 'Priority']],
        body: tableData,
        theme: 'grid',
        headStyles: {
          fillColor: primaryColor,
          textColor: 255,
          fontStyle: 'bold'
        },
        bodyStyles: {
          textColor: darkColor,
          fontSize: 9
        },
        columnStyles: {
          0: { cellWidth: 15, halign: 'center' },
          2: { cellWidth: 25, halign: 'center' }
        },
        styles: {
          cellPadding: 3,
          fontSize: 9
        },
        didDrawCell: (data) => {
          if (data.section === 'body' && data.column.index === 2) {
            const priority = data.cell.raw as string;
            let color: number[] = darkColor;
            
            if (priority === 'High') color = dangerColor;
            else if (priority === 'Medium') color = warningColor;
            else if (priority === 'Low') color = successColor;
            
            pdf.setTextColor(...color);
            pdf.setFont("helvetica", "bold");
          }
        }
      });

      yPosition = (pdf as any).lastAutoTable.finalY + 10;
    }

    /** -------------------------------- PRIORITY BREAKDOWN -------------------------------- **/
    if (report.recommendations && report.recommendations.length > 0) {
      if (yPosition > pageHeight - 50) {
        pdf.addPage();
        yPosition = margin;
      }

      pdf.setFillColor(...primaryColor);
      pdf.rect(margin, yPosition, contentWidth, 12, "F");
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(16);
      pdf.text("PRIORITY BREAKDOWN", margin + 8, yPosition + 8);
      yPosition += 20;

      const priorityCounts = {
        High: report.recommendations.filter(r => r.priority === 'High').length,
        Medium: report.recommendations.filter(r => r.priority === 'Medium').length,
        Low: report.recommendations.filter(r => r.priority === 'Low').length
      };

      const total = report.recommendations.length;
      const chartRadius = 30;
      const chartCenterX = margin + contentWidth / 2;
      const chartCenterY = yPosition + 50;

      // Draw pie chart
      let startAngle = 0;
      const priorities = [
        { priority: 'High', color: dangerColor, count: priorityCounts.High },
        { priority: 'Medium', color: warningColor, count: priorityCounts.Medium },
        { priority: 'Low', color: successColor, count: priorityCounts.Low }
      ];

      priorities.forEach(item => {
        if (item.count > 0) {
          const angle = (item.count / total) * 360;
          pdf.setFillColor(...item.color);
         // Draw pie chart manually with paths
let startAngle = 0;
const radius = chartRadius;

priorities.forEach(item => {
  if (item.count > 0) {
    const sliceAngle = (item.count / total) * 2 * Math.PI; // in radians
    const endAngle = startAngle + sliceAngle;

    // Convert polar to cartesian
    const x1 = chartCenterX + radius * Math.cos(startAngle);
    const y1 = chartCenterY + radius * Math.sin(startAngle);
    const x2 = chartCenterX + radius * Math.cos(endAngle);
    const y2 = chartCenterY + radius * Math.sin(endAngle);

    pdf.setFillColor(...item.color);

    // Start path
    pdf.lines(
      [
        [x1 - chartCenterX, y1 - chartCenterY],
        [x2 - x1, y2 - y1],
        [chartCenterX - x2, chartCenterY - y2]
      ],
      chartCenterX,
      chartCenterY,
      [1, 1],
      'F'
    );

    startAngle = endAngle;
  }
});

          startAngle += angle;
        }
      });

      // Legend
      const legendX = margin;
      const legendY = yPosition + 100;
      
      priorities.forEach((item, index) => {
        if (item.count > 0) {
          const y = legendY + (index * 15);
          
          pdf.setFillColor(...item.color);
          pdf.rect(legendX, y, 8, 8, 'F');
          
          pdf.setTextColor(...darkColor);
          pdf.setFontSize(9);
          pdf.text(`${item.priority}: ${item.count} recommendations (${Math.round((item.count / total) * 100)}%)`, legendX + 12, y + 6);
        }
      });

      yPosition += 120;
    }

    /** -------------------------------- FOOTER -------------------------------- **/
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Page number
      pdf.setFontSize(10);
      pdf.setTextColor(150, 150, 150);
      pdf.text(
        `Page ${i} of ${totalPages}`,
        pageWidth - margin,
        pageHeight - 10,
        { align: "right" }
      );

      // Confidential watermark for all pages except cover
      if (i > 1) {
        pdf.setFontSize(8);
        pdf.setTextColor(200, 200, 200);
        pdf.text("CONFIDENTIAL - RANKSEO.IN", pageWidth / 2, pageHeight - 10, {
          align: "center",
        });
      }

      // Border
      pdf.setDrawColor(226, 232, 240);
      pdf.rect(margin - 5, margin - 5, contentWidth + 10, pageHeight - margin * 2 + 10, "D");
    }

    /** -------------------------------- SAVE PDF -------------------------------- **/
    pdf.save(
      `SEO-Audit-Report-${url.replace(/https?:\/\//, "").split("/")[0]}-${new Date().getTime()}.pdf`
    );
  };

  // Helper function to clean analysis text
  const cleanAnalysisText = (text: string): string => {
    return text
      .replace(/\*\*/g, '') // Remove **bold** markers
      .replace(/\*/g, '')   // Remove *italic* markers
      .replace(/^- /gm, '') // Remove bullet points
      .replace(/^\d+\.\s/gm, '') // Remove numbered lists
      .replace(/#{1,6}\s/g, '') // Remove headers
      .replace(/---+/g, '') // Remove horizontal lines
      .replace(/\n\s*\n\s*\n/g, '\n\n') // Remove excessive newlines
      .replace(/([A-Z][A-Za-z\s]+):/g, '\n$1:\n') // Format section headers
      .trim();
  };

  return (
    <button
      onClick={handleDownloadPDF}
      className="px-4 sm:px-6 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition-colors flex items-center gap-2 text-sm sm:text-base shadow-lg"
    >
      <DownloadIcon />
      Download PDF Report
    </button>
  );
};

// Download icon component
const DownloadIcon = () => (
  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
  </svg>
);

export default PDFGenerator;
